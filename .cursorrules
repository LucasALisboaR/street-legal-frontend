# Gearhead BR Development Rules

## 1. Project Overview & Stack
- **Purpose**: Gearhead BR is a Brazilian social network for automotive enthusiasts, built as a mobile-first Flutter application with a dark, neon-inspired UI and map-based experiences.
- **Core technologies**:
  - **Framework**: Flutter (Material 3).
  - **Language**: Dart (SDK >= 3.2).
  - **State management**: BLoC (`flutter_bloc`, `equatable`).
  - **Navigation**: GoRouter.
  - **DI**: GetIt + Injectable (manual GetIt registration currently in use).
  - **Networking**: Dio with interceptors and centralized endpoints.
  - **Backend/Cloud**: Firebase Auth + Firebase Core.
  - **Maps**: Mapbox + Geolocator/Compass.

## 2. Architecture & Directory Structure
- **High-level structure** (Clean Architecture per feature):
  - `lib/core/` → shared infrastructure (DI, theme, routing, constants, network, reusable widgets).
  - `lib/features/<feature>/` → feature-scoped layers:
    - `data/` (repositories, data sources, services)
    - `domain/` (entities, repositories interfaces, use cases)
    - `presentation/` (UI pages, widgets, BLoCs)
  - `lib/main.dart` → app bootstrap (Firebase, Mapbox, DI, theme, router).
- **Where to place code**:
  - **UI widgets**: feature-specific widgets under `presentation/widgets/`. Shared widgets under `core/widgets/`.
  - **Business logic**: BLoCs under `presentation/bloc/`, use cases under `domain/usecases/`.
  - **Entities & types**: `domain/entities/` for core business types.
  - **Data access**: `data/` for repositories and services; `core/network/` for HTTP primitives.
  - **Constants/tokens**: `core/constants/` and `core/theme/` for UI tokens and global constants.

## 3. Coding Standards
- **Naming conventions** (follow Dart/Flutter idioms):
  - **Files & directories**: `snake_case.dart` (e.g., `login_bloc.dart`, `map_page.dart`).
  - **Classes & enums**: `PascalCase` (e.g., `AppRouter`, `MapBloc`).
  - **Variables & functions**: `camelCase` (e.g., `configureDependencies`, `darkTheme`).
- **Preferred patterns**:
  - **Functional/Stateless widgets** for UI where possible; use `StatefulWidget` only when local state is needed.
  - **Composition over inheritance**; extend only when Flutter framework requires it.
  - **Clean Architecture** boundaries: presentation → domain → data. Keep UI free of networking and persistence logic.
- **Type usage**:
  - Use **Dart strong typing** throughout. Prefer `final` for immutable values.
  - **Interfaces vs. concrete types**: expose repository interfaces in `domain/`, implement in `data/`.
  - Use `Either` (via `dartz`) for result/error handling in data & domain layers, consistent with `BaseDataSource` patterns.
- **Linting**: adhere to `flutter_lints` defaults (no custom lint file beyond `analysis_options.yaml`).

## 4. State Management & Data Fetching
- **State management**: use BLoC (`flutter_bloc`) with `Event`/`State` files colocated in `presentation/bloc/`.
- **Dependency injection**: register services, repositories, use cases, and BLoCs in `core/di/injection.dart`.
- **Data fetching**:
  - Use **Dio** via `ApiClient` with interceptors for auth, errors, and logging.
  - Centralize endpoints in `core/network/api_endpoints.dart`.
  - Data sources should extend `BaseDataSource` and use `executeRequest` with `Either<ApiError, T>`.

## 5. Styling & UI
- **Theme system**: use `AppTheme.darkTheme` and `AppColors` tokens; avoid hard-coded colors.
- **Typography**: use Google Fonts (`Orbitron` + `Rajdhani`) via the theme.
- **Design tokens**: use `AppConstants` for spacing, durations, and radii.
- **Reusable widgets**: prefer feature widgets for feature styling, or `core/widgets` for shared UI elements.

## 6. Best Practices & Constraints
### Do
- **Do** add new endpoints to `api_endpoints.dart` and data sources under `core/network/data_sources/`.
- **Do** register new dependencies in `core/di/injection.dart` to keep DI centralized.
- **Do** keep UI purely declarative; move logic into BLoC/use cases.
- **Do** keep Map-related functionality in `features/map` and use Mapbox services for location/navigation tasks.

### Don’t
- **Don’t** bypass `ApiClient` or create ad-hoc HTTP clients; use Dio + interceptors.
- **Don’t** store secrets in code; rely on runtime env (`--dart-define`) or platform configs.
- **Don’t** add try/catch blocks around imports (project-wide rule).
- **Don’t** hardcode colors or fonts; use `AppTheme`/`AppColors` tokens instead.

### Libraries to Use/Avoid
- **Use**: `flutter_bloc`, `go_router`, `get_it`, `dio`, `dartz`, Firebase, Mapbox.
- **Avoid**: alternative DI/state libraries (e.g., Provider/Riverpod/MobX) unless explicitly approved, to keep the architecture consistent.

## 7. AI Interaction Rules
- Be concise but complete; summarize intent before coding.
- Always propose changes that align with Clean Architecture boundaries.
- Prefer minimal diffs and respect existing naming patterns.
- Explain complex logic briefly before implementation.
- When unsure, ask clarifying questions before making large architectural changes.

---
This document is the **single source of truth** for new contributions. Keep it updated as the architecture evolves.
